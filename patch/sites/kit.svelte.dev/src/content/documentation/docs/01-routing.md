---
title: Маршруты
---

Сердцем SvelteKit является *роутер основанный на файловой системе*. Это означает, что структура вашего приложения определяется структурой файлов его исходников – в частности содержимым папки `src/routes`.

> Можно указать другую директорию в файле [конфигурации проекта](#configuration).

Существует два типа маршрутов — **страницы** и **эндпоинты**.

### Страницы

Страницы — это компоненты Svelte, описанные в файлах `.svelte`(или любой файл с расширением, указанным в [`config.extensions`](#configuration)). Когда пользователь впервые посещает приложение, ему будет отправлена сгенерированная на сервере версия запрошенной страницы, а также некоторый JavaScript, который выполняет 'гидрацию' страницы и инициализирует роутер на стороне клиента. С этого момента навигация на другие страницы будет полностью выполняться на стороне клиента обеспечивая очень быстрое перемещение, что типично для клиентских приложений.

Имя файла определяет маршрут. Например, `src/routes/index.svelte` — корневой файл вашего сайта:


```html
<!-- src/routes/index.svelte -->
<svelte:head>
	<title>Добро пожаловать!</title>
</svelte:head>

<h1>Приветствую вас на моём сайте!</h1>
```

Файл с именем `src/routes/about.svelte` или `src/routes/about/index.svelte` будет соответствовать маршруту `/about`:

```html
<!-- src/routes/about.svelte -->
<svelte:head>
	<title>О сайте</title>
</svelte:head>

<h1>Информация о сайте</h1>
<p>Это самый лучший сайт!</p>
```

Динамические параметры задаются при помощи квадратных скобок [...]. Например, можно определить страницу, отображающую статью из блога, таким образом – `src/routes/blog/[slug].svelte`. Скоро мы увидим как получить доступ к этому параметру в 
[функции load](#loading) или [в хранилище страницы](#modules-app-stores). 

### Эндпоинты


Эндпоинты — это модули, написанные в файлах `.js` (или `.ts`), которые экспортируют функции, соответствующие HTTP методам. Каждая функция получает в качестве аргументов объекты HTTP `request` и `context`. Например, наша гипотетическая страница блога `/blog/cool-article`, может запрашивать данные из `/blog/cool-article.json`, который может быть представлен эндпоинтом `src/routes/blog/[slug].json.js`:

```ts
type Request = {
	host: string;
	method: 'GET';
	headers: Record<string, string>;
	path: string;
	params: Record<string, string | string[]>;
	query: URLSearchParams;
	body: string | Buffer | ReadOnlyFormData;
};

type Response = {
	status?: number;
	headers?: Record<string, string>;
	body?: any;
};
```

```js
import db from '$lib/database';

/**
 * @param {import('@sveltejs/kit').Request} request
 * @param {any} context
 * @returns {import('@sveltejs/kit').Response}
 */
export async function get(request, context) {
	// у нас есть доступ к параметру `slug`, потому что
	// файл называется [slug].json.js
	const { slug } = request.params;

	const article = await db.get(slug);

	if (article !== null) {
		return {
			body: {
				article
			}
		};
	} else {
		return {
			status: 404,
			body: {
				error: 'Не найдено'
			}
		};
	}
}
```
Поскольку модуль запускается только на сервере (или при сборке сайта, в случае [пререндера](#пререндер)), вы можете легко получить доступ к вещам вроде базы данных. (Пока не обращайте внимание на `$lib`, об этом мы узнаем [позднее](#$lib).)

Второй аргумент `context` – это нечто, что вы определили в [Установках](#setup) при необходимости.

Цель данной функции – вернуть объект `{status, headers, body}`, который является ответом на запрос. Если `body` является объектом и в `headers` нет заголовка `content-type`, то он по автоматически превратится в JSON строку.

Для эндпоинтов, которые должны обрабатывать иные HTTP методы, например POST, экспортируйте соответствующую функцию:

```js
export function post(request, context) {...}
```

Поскольку `delete` является зарезервированным словом JavaScript, запросы методом DELETE обрабатываются функцией с именем `del`.

> Мы не взаимодействуем с объектами `req`/`res`, которые могут быть вам знакомы из Node-модуля `http` или фреймворков типа Express, потому что они доступны только на некоторых платформах. Вместо этого, SvelteKit переводит возвращенный объект в то что будет понятно платформе, куда вы будете загружать свое готовое приложение. 
>
> Свойство `body` у объекта `request` будет существовать только в случае POST запросов. Если вы отправили данные формы, оно будет являться объектом [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData), доступным только для чтения.


### Приватные модули 

Пути файлов, в которых есть часть начинающаяся с символа нижнего подчеркивания, такие как `src/routes/foo/_Private.svelte` или `src/routes/bar/_utils/cool-util.js`, будут спрятаны от роутера, но могут быть импортированы в другие файлы, которые ему видны.


### Динамические маршруты

Маршрут может иметь несколько динамических параметров, например `src/routes/[category]/[item].svelte`, или даже `src/routes/[category]-[item].svelte`. Если количество частей маршрута заранее неизвестно, можно воспользоваться rest-синтаксисом – например, реализация просмотра файлов на GitHub будет выглядеть так...

```bash
/[org]/[repo]/tree/[branch]/[...file]
```

...и в данном случае запрос для маршрута `/sveltejs/kit/tree/master/documentation/docs/01-routing.md` будет преобразован в следующие параметры, доступные на этой странице:

```js
{
	org: 'sveltejs',
	repo: 'kit',
	branch: 'master',
	file: ['documentation', 'docs', '01-routing.md']
}
```

Вы даже можете использовать набор регулярных выражений для более точного определения подходит маршрут под заданный шаблон или нет:

```bash
# подойдет для /2021/04/25, но не для /a/b/c или /1/2/3
src/routes/[year(\d{4})]/[month(\d{2})]/[day(\d{2})].svelte
```
Из-за технических ограничений в регулярных выражениях нельзя использовать следующие символы: `/`, `\`, `?`, `:`, `(` и `)`.
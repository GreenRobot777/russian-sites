---
title: Маршруты
---

Сердцем SvelteKit является _роутер основанный на файловой системе_. Это означает, что структура вашего приложения определяется структурой файлов его исходников – в частности содержимым папки `src/routes`.

> Можно указать другую директорию в файле [конфигурации проекта](#конфигурация).

Существует два типа маршрутов — **страницы** и **эндпоинты**.

### Страницы

Страницы — это компоненты Svelte, описанные в файлах `.svelte`(или любой файл с расширением, указанным в [`config.extensions`](#конфигурация)). Когда пользователь впервые посещает приложение, ему будет отправлена сгенерированная на сервере версия запрошенной страницы, а также некоторый JavaScript, который выполняет 'гидрацию' страницы и инициализирует роутер на стороне клиента. С этого момента навигация на другие страницы будет полностью выполняться на стороне клиента обеспечивая очень быстрое перемещение, что типично для клиентских приложений.

Имя файла определяет маршрут. Например, `src/routes/index.svelte` — корневой файл вашего сайта:


```html
<!-- src/routes/index.svelte -->
<svelte:head>
	<title>Добро пожаловать!</title>
</svelte:head>

<h1>Приветствую вас на моём сайте!</h1>
```

Файл с именем `src/routes/about.svelte` или `src/routes/about/index.svelte` будет соответствовать маршруту `/about`:

```html
<!-- src/routes/about.svelte -->
<svelte:head>
	<title>О сайте</title>
</svelte:head>

<h1>Информация о сайте</h1>
<p>Это самый лучший сайт!</p>
```

Динамические параметры задаются при помощи квадратных скобок [...]. Например, можно определить страницу, отображающую статью из блога, таким образом – `src/routes/blog/[slug].svelte`. Скоро мы увидим как получить доступ к этому параметру в 
[функции load](#загрузка-данных) или [в хранилище страницы](#модули-app-stores). 

### Эндпоинты


Эндпоинты — это модули, написанные в файлах `.js` (или `.ts`), которые экспортируют функции, соответствующие HTTP методам. Каждая функция получает в качестве аргументов объекты HTTP `request` и `context`. Например, наша гипотетическая страница блога `/blog/cool-article`, может запрашивать данные из `/blog/cool-article.json`, который может быть представлен эндпоинтом `src/routes/blog/[slug].json.js`:

```ts
type Request = {
	host: string;
	method: 'GET';
	headers: Record<string, string>;
	path: string;
	params: Record<string, string | string[]>;
	query: URLSearchParams;
	body: string | Buffer | ReadOnlyFormData;
};

type Response = {
	status?: number;
	headers?: Record<string, string>;
	body?: any;
};
```

```js
import db from '$lib/database';

/**
 * @param {import('@sveltejs/kit').Request} request
 * @param {any} context
 * @returns {import('@sveltejs/kit').Response}
 */
export async function get(request, context) {
	// у нас есть доступ к параметру `slug`, потому что
	// файл называется [slug].json.js
	const { slug } = request.params;

	const article = await db.get(slug);

	if (article) {
		return {
			body: {
				article
			}
		};
	} 
}
```
> Если из функции ничего не возвращается, это вызовет ответ с кодом ошибки 404.

Поскольку модуль запускается только на сервере (или при сборке сайта, в случае [пререндера](#пререндер)), вы можете легко получить доступ к вещам вроде базы данных. (Пока не обращайте внимание на `$lib`, об этом мы узнаем [позднее](#модули-lib).)

Второй аргумент `context` – это нечто, что вы определили в [Установках](#установки) при необходимости.

Цель данной функции – вернуть объект `{status, headers, body}`, который является ответом на запрос. Если `body` является объектом и в `headers` нет заголовка `content-type`, то он по автоматически превратится в JSON строку.

Для эндпоинтов, которые должны обрабатывать иные HTTP методы, например POST, экспортируйте соответствующую функцию:

```js
export function post(request, context) {...}
```

Поскольку `delete` является зарезервированным словом JavaScript, запросы методом DELETE обрабатываются функцией с именем `del`.

> Мы не взаимодействуем с объектами `req`/`res`, которые могут быть вам знакомы из Node-модуля `http` или фреймворков типа Express, потому что они доступны только на некоторых платформах. Вместо этого, SvelteKit переводит возвращенный объект в то что будет понятно платформе, куда вы будете загружать свое готовое приложение. 
>
> Свойство `body` у объекта `request` будет существовать только в случае POST запросов. Если вы отправили данные формы, оно будет являться объектом [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData), доступным только для чтения.

### Приватные модули 

Пути файлов, в которых есть часть начинающаяся с символа нижнего подчеркивания, такие как `src/routes/foo/_Private.svelte` или `src/routes/bar/_utils/cool-util.js`, будут спрятаны от роутера, но могут быть импортированы в другие файлы, которые ему видны.


### Дополнительно

#### Rest-параметры

Маршрут может иметь несколько динамических параметров, например `src/routes/[category]/[item].svelte`, или даже `src/routes/[category]-[item].svelte`. Если количество частей маршрута заранее неизвестно, можно воспользоваться rest-синтаксисом – например, реализация просмотра файлов на GitHub будет выглядеть так...

```bash
/[org]/[repo]/tree/[branch]/[...file]
```

...и в данном случае запрос для маршрута `/sveltejs/kit/tree/master/documentation/docs/01-routing.md` будет преобразован в следующие параметры, доступные на этой странице:

```js
{
	org: 'sveltejs',
	repo: 'kit',
	branch: 'master',
	file: 'documentation/docs/01-routing.md'
}
```
#### Перебор маршрутов

В случае, когда в приложении существует несколько маршрутов, которые подходят под заданный URL, SvelteKit будет пробовать загрузить каждый из них, пока кто-то из них не ответит. Например у вас есть такие маршруты... 

```bash
src/routes/[baz].js
src/routes/[baz].svelte
src/routes/[qux].svelte
src/routes/foo-[bar].svelte
```
...и вы собираетесь перейти на страницу `/foo-xyz`, в таком случае SvelteKit сначала попробует загрузить `foo-[bar].svelte`, потому что он подходит больше всех, затем попробует `[baz].js` (который, тоже подходит для `/foo-xyz`, но менее специфичен), затем `[baz].svelte` и `[qux].svelte` в алфавитном порядке (эндпоинты имеют больший приоритет, чем страницы). Первый маршрут, который ответит – то есть страница, которая вернёт что-то из функции [`load`](#загрузка-данных) или страница в котрой этой функции нет, или эндпоинт который что-то возвращает – будет обрабатывать поступивший запрос.

Если ни одна страница или эндпоинт не ответит на запрос, SvelteKit вернет ответ с кодом 404.